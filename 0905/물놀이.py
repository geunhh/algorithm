# 홈 방범 서비스

## 문제 해석

+ k값에
따라
운영
비용과
탐색할
수
있는
범위가
늘어난다.
+ k
값(탐색범위)
과(i, j)
탐색시작
위치를
기준으로
탐색을
진행했을
때 ** 손해를
보지
않고 **, 서비스를
제공할
수
있는 ** 집의
최대
개수 ** 를
찾기

+ k의
크기에
따라
마름모
모양
영역
내에
존재하는
집의
개수를
세야
함.
+ cnt(집
개수) *M(지불비용) - K_cost(운영비용) ≥ 0
일
때
최대
집
개수를
찾아야
함.
+ k_cost: 운영
비용 = K * K + (K - 1) * (K - 1)
## 아이디어

---

### 1번 아이디어 -> 실패

1.
집을
찾는다 → 집
좌표를
저장해둠
2.
집
좌표를
기준으로
K를
키워가면서
완전
탐색한다.
-  마름모
탐색
어떻게
만들지?
3.
이득이
0
이상이고, lst[i][j] == 1
이면
cnt
올려주자

-> 실패.: 집
tc
2
번만
미리
봤어도
이런
생각은
안
했음

### 2번 아이디어.

1.
K를
1
부터
순회하며
완전
탐색을
한다.
- k == 0 → max_cnt
는
반드시
1
2.
마름모
모양으로
탐색하기
위한
코드를
구현해서
탐색하며,
- 범위
내에
들어감 + lst[i][j]
가
1
이면(집이
있으면) cnt를
세준다.
3.
마름모
탐색이
끝나면, 이득을
계산하고,
- 이득이
0
이상이면, max_cnt
와
비교하여
갱신해준다.

## 코드
```python
'''
#	마름모 만들기
    row 별 column을 순회하는데 
    => [0],[-1,0,1],[-2,-1,0,1,2],[-1,0,1]... 이런식으로 돌아야 함

    그래서 k1이라는 변수를 0으로 설정하고,
    i가 중간값이 되는 순간부터 -1 해주면서 마름모 모양으로 탐색

    ex) k==3(-2,-1,0,1,2)이고, ci가 6이면
        i -> 4 5 6 7 8, 
        j는 4에서 5까지 +=1, 6부터 -=1 적용
'''


def check(K, ci, cj):  # k, 중심이 될 i,j
    global result
    k1 = 0  # 열( j ) 탐색할 때 개수 범위 조절 해주기 위한 변수
    cur_cnt = 0  # 현재 범위에서의 집 개수

    # 2. 마름모로 탐색
    # 2-1. 행순회
    # k가 2 이상일 때 자신을 기준으로 -k부터 +k 까지 탐색
    for i in range(ci - K, ci + K + 1):
        if i >= 0 and i < N:  # 범위 내에 들어가면
            # 2-2. 열순회
            for j in range(-k1, k1 + 1):

                # 조사하려는 j가 범위 내에 있고 1이라면 cnt 증가
                if 0 <= cj + j < N and lst[i][cj + j] == 1:
                    cur_cnt += 1
        # 열을 마름모로 만들기 위해 아래 처리 해줌.
        if i < ci:  # ci,cj 까지는 +=1 해서 영역 넓혀주다가
            k1 += 1
        else:  # 이후로는 좁혀줌
            k1 -= 1

    # profit 계산
    K = K + 1  # K가 -1 된 상태로 루프를 돌렸기 때문에 +1 해서 이득 계산
    cur_cost = M * cur_cnt - (K * K + (K - 1) * (K - 1))  # 계산

    # 손해가 아니고, 집 개수가 result(max_cnt)보다 클 때 갱신.
    if cur_cost >= 0 and cur_cnt > result:
        result = cur_cnt


for tc in range(1, int(input()) + 1):
    N, M = map(int, input().split())

    lst = [list(map(int, input().split())) for _ in range(N)]
    result = 1  # 최대 집 개수 -> default

    # 1. 순회시작
    for k in range(1, N + 1):  # k 순회 1이지만, 2부터 순회
        for x in range(N):
            for y in range(N):
                check(k, x, y)

    print(f'#{tc} {result}')
```
## 3번 아이디어
```python
** 위
코드에서
추가
생각
및
시도. **
시간을
줄여보자
if K 가 n일 때 최대 집 개수 < K-1일때의 최대 집 개수:
    -> 즉, 최대값이
    갱신되지
    않으면, 앞으로도
    갱신되지
    않음.
    더
    탐색할
    필요가
    없다고
    판단.

################################################

for k in range(1, N + 1):  # k 순회 1이지만, 2부터 순회
    # k 갱신할 때마다 prev_result도 갱신
    prev_result = result << --- 얘랑
    for x in range(N):
        for y in range(N):
            check(k, x, y)
    if prev_result == result:  <<
        --- 얘
    추가했는데,
    break << --- 얘도

################################################

근데
시간이
안
줄어든다.까비
```